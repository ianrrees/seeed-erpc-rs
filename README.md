# seeed-erpc-rs

[![Crates.io](https://img.shields.io/crates/v/seeed-erpc.svg)](https://crates.io/crates/seeed-erpc) [![usbd-hid](https://docs.rs/seeed-erpc/badge.svg)](https://docs.rs/seeed-erpc)

An embedded / no-std implementation of Seeed Studio's eRPC protocol, which is used to communicate with
their RTL8720 firmware.

Most notably, this is the main firmware for the wifi chip in their [Wio Terminal](https://www.seeedstudio.com/Wio-Terminal-p-4509.html) product.

WIP - most RPCs are not yet implemented.

### Usage

Have a look at the [Wio terminal](https://github.com/atsamd-rs/atsamd/blob/96f837f24e8554ebad1fc7c56f7d5cd6938f198a/boards/wio_terminal/src/wifi.rs#L145)
BSP implementation for an example of how to use this.

To summarize:

1. Generate the request bytes by combining the bytes generated by `RPC::header(sequence_number)` with the bytes extended from `RPC::args(&mut buff)`.
2. Transmit `FrameHeader::new_from_msg(request_bytes)` followed by `request_bytes` itself.
3. Receive 4 bytes from the remote end (the frame header), and parse them using `FrameHeader::parse()`.
4. Receive the response payload by reading the next `frame_header.msg_length` bytes.
5. Verify the CRC by calling `frame_header.check_crc(&payload_bytes)`.
6. Finally, get the result of the RPC by calling `RPC::parse(&payload_bytes)`.

#### Handling 'callback' messages

Sometimes the remote end will send you data even if you didn't ask for it. These are the 'callback' service 'oneway' RPCs.
Handling these is a little annoying. The trick is to repeat steps 3-6 above if you get the error `Err::NotOurs` back from `RPC::parse()`.
